package Java_study_0123;

public class study2_0123 {

	public static void main(String[] args) {
		// 비트 연산자 정리
		
		// 비트 논리 연산자
		System.out.println( 27 & 13); // and 연산 : 두 개의 2진수 값의 각 자리 *개념 ex) 27= 11011, 13 = 01101 => 11011*01101 = 01001 => 9
		System.out.println( 27 | 13); // or 연산 : 두 개의 2진수 값의 각 자리가 하나라도 1이면 1을 반영하는 개념 ex) 27= 11011, 13 = 01101 = 11111 => 31
		System.out.println( 27 ^ 13); // xor 연산 : 1과 1 또는 0과0이 만나면 0, 0과 1이 만나야 1개념 ex) 27= 11011, 13 = 01101 = 10110 => 22
		System.out.println(~13); // not 연산 : 양수 또는 0을 연산하는 경우 현재 수를 음수로 전환 후 -1, 음수를 연산하는 경우 양수 전환 후 -1로 생각하면됨. 상세 개념은 찾아볼것 ex> ~13 = -14, 0 = -1, -15 = 14
		// 실수를 2진수 변환 방법 소수점 부분에 *2를 해서 정수 부분이 2진수 값이며 소수점이 계속 붙어있으면 과정 반복 실수는 정확도가 떨어짐
		// ex) 0.625 2진수 만들기 => 0.625*2 = 1.25 2진수 1과 0.25 =>0.25*2 = 0.5 2진수 0과 0.5 => 0.5*2 = 1.0 정수 1과 소수0 결론 : 0.625의 2진수값은 0.101 
	
		//비트 쉬프트 연산자
		System.out.println(21<<2); // 쉬프트 연산 : 오른쪽의 숫자값만큼 2진수 값을 옮김 방향은 쉬프트 방향으로 결정 ex) 16 << 2 => 000010000을 001000000으로 만드는 것
								   //																  9 << 3 => 00001001을 001001000으로 만듬 
	
	}

}
